#!/usr/bin/env node

/**
 * Module dependencies.
 */
var mongoose = require('mongoose')
var app = require('../app');
var debug = require('debug')('new-project3:server');
var http = require('http');
var BlockChainSchema = require('../schemes/BlockChainSchema.js');
var userModel = require('../schemes/UserSchema.js');
var bcrypt = require("bcrypt");
var {
  savedTransactions
} = require('./savedTransactions.js');

var {
  keys
} = require('./keys.js');

const {
  Transaction
} = require('../models/Transaction.js');
var EC = require('elliptic').ec;
const ObjectId = require('mongoose/lib/schema/objectid');
var ec = new EC('secp256k1');
/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);
initiate()

async function initiate() {
  let sashaCoin = await createBC()
  createUsers()
}


//Create 3 Users
async function createUsers() {
  const salt = await bcrypt.genSalt(10);
  for (let i = 0; i < 3; i++) {
    const user = new userModel({
      _id: mongoose.Types.ObjectId(i),
      username: `User${i+1}`,
      publicKey: keys[i].publicKey,
      privateKey: keys[i].privateKey,
      password: '123456',
      mail: `User${i+1}@gmail.com`
    });
    user.password = await bcrypt.hash('123456', salt);
    user.save().catch(err => {
      console.log("User Exist, Continue");

    })
  }
}

//Create Block Chain with 18 transactions, and 3 mining actions
async function createBC() {
  let sashaCoin = new BlockChainSchema({
    _id: 1,
    chain: [],
    difficulty: 2,
    pendingTransaction: [],
    miningReward: 100
  })
  sashaCoin.chain.push(sashaCoin.createGenesisBlock())
  for (let i = 0; i < 3; i++) {
    const key = keys[i].publicKey;
    sashaCoin.addNewUser(key)
  }
  for (let i = 0; i < 18; i++) {
    var tx = new Transaction(savedTransactions[i].fromAddress, savedTransactions[i].toAddress, savedTransactions[i].amount, i)
    tx.signTransaction(ec.keyFromPrivate(savedTransactions[i].privateKey))
    await sashaCoin.addTransaction(tx)
    if ((i + 1) % 4 == 0) {
      console.log("i = " + i);
      sashaCoin.miningPendingTransaction(keys[0].publicKey)
    }
  }
  sashaCoin.save().catch(err => {
    console.log("Blockchain Already Exist, Continue");
  })
}


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string' ?
    'Pipe ' + port :
    'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string' ?
    'pipe ' + addr :
    'port ' + addr.port;
  debug('Listening on ' + bind);
}